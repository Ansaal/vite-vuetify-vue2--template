'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var unplugin$1 = require('unplugin');
var pluginutils = require('@rollup/pluginutils');
var MagicString = require('magic-string');
var reactivityTransform = require('@vue/reactivity-transform');
var utils = require('@antfu/utils');
var compilerCore = require('@vue/compiler-core');
var compilerDom = require('@vue/compiler-dom');
var shared = require('@vue/shared');
var babel = require('@babel/core');
var parser = require('@babel/parser');
var g = require('@babel/generator');
var babel_traverse = require('@babel/traverse');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);
var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
var g__default = /*#__PURE__*/_interopDefaultLegacy(g);
var babel_traverse__namespace = /*#__PURE__*/_interopNamespace(babel_traverse);

var _a, _b, _c;
const t = (babel__namespace.default || babel__namespace).types;
const generate = (g__default["default"].default || g__default["default"]);
const traverse = (_c = (_b = (_a = babel_traverse__namespace === null || babel_traverse__namespace === void 0 ? void 0 : babel_traverse__namespace.default) === null || _a === void 0 ? void 0 : _a.default) !== null && _b !== void 0 ? _b : babel_traverse__namespace === null || babel_traverse__namespace === void 0 ? void 0 : babel_traverse__namespace.default) !== null && _c !== void 0 ? _c : babel_traverse__namespace;

function getIdentifierDeclarations(nodes) {
    let result;
    let programScopeUid;
    traverse(t.file(t.program(nodes)), {
        Program(path) {
            result = new Set(Object.keys(path.scope.bindings));
            programScopeUid = path.scope.uid;
        },
        // FIXME: babel bug, temporary add TSEnumDeclaration and TSModuleDeclaration logic
        TSEnumDeclaration(path) {
            if (path.scope.uid === programScopeUid)
                result.add(path.node.id.name);
        },
        TSModuleDeclaration(path) {
            if (path.scope.uid === programScopeUid) {
                const id = path.node.id;
                if (id.type === 'Identifier')
                    result.add(id.name);
            }
        },
    });
    return Array.from(result);
}
function getFileGlobals(result) {
    let globals;
    let programScopeUid;
    traverse(result, {
        Program(path) {
            globals = new Set(Object.keys(path.scope.globals));
            programScopeUid = path.scope.uid;
        },
        // FIXME: babel bug, temporary add TSEnumDeclaration and TSModuleDeclaration logic
        TSEnumDeclaration(path) {
            if (path.scope.uid === programScopeUid)
                globals.delete(path.node.id.name);
        },
        TSModuleDeclaration(path) {
            if (path.scope.uid === programScopeUid) {
                const id = path.node.id;
                if (id.type === 'Identifier')
                    globals.delete(id.name);
            }
        },
    });
    return Array.from(globals);
}

const pascalize = (str) => shared.capitalize(shared.camelize(str));
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const exhaustiveCheckReturnUndefined = (param) => undefined;

/* eslint-disable one-var */
var NodeTypes;
(function (NodeTypes) {
    NodeTypes.ROOT = 0, NodeTypes.ELEMENT = 1, NodeTypes.TEXT = 2, NodeTypes.COMMENT = 3, NodeTypes.SIMPLE_EXPRESSION = 4, NodeTypes.INTERPOLATION = 5, NodeTypes.ATTRIBUTE = 6, NodeTypes.DIRECTIVE = 7, NodeTypes.COMPOUND_EXPRESSION = 8, NodeTypes.IF = 9, NodeTypes.IF_BRANCH = 10, NodeTypes.FOR = 11, NodeTypes.TEXT_CALL = 12, NodeTypes.VNODE_CALL = 13, NodeTypes.JS_CALL_EXPRESSION = 14, NodeTypes.JS_OBJECT_EXPRESSION = 15, NodeTypes.JS_PROPERTY = 16, NodeTypes.JS_ARRAY_EXPRESSION = 17, NodeTypes.JS_FUNCTION_EXPRESSION = 18, NodeTypes.JS_CONDITIONAL_EXPRESSION = 19, NodeTypes.JS_CACHE_EXPRESSION = 20, NodeTypes.JS_BLOCK_STATEMENT = 21, NodeTypes.JS_TEMPLATE_LITERAL = 22, NodeTypes.JS_IF_STATEMENT = 23, NodeTypes.JS_ASSIGNMENT_EXPRESSION = 24, NodeTypes.JS_SEQUENCE_EXPRESSION = 25, NodeTypes.JS_RETURN_STATEMENT = 26;
})(NodeTypes || (NodeTypes = {}));
var ElementTypes;
(function (ElementTypes) {
    ElementTypes.ELEMENT = 0, ElementTypes.COMPONENT = 1, ElementTypes.SLOT = 2, ElementTypes.TEMPLATE = 3;
})(ElementTypes || (ElementTypes = {}));
const BUILD_IN_DIRECTIVES = new Set([
    'if',
    'else',
    'else-if',
    'for',
    'once',
    'model',
    'on',
    'bind',
    'slot',
    'slot-scope',
    'key',
    'ref',
    'text',
    'html',
    'show',
    'pre',
    'cloak',
    // 'el',
    // 'ref',
]);
function getComponents(node) {
    var _a;
    const current = node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.COMPONENT
        ? [node.tag]
        : node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT
            ? [node.tag]
            : [];
    const children = node.type === NodeTypes.IF
        ? node.branches
        : node.type === NodeTypes.ELEMENT
            || node.type === NodeTypes.IF_BRANCH
            || node.type === NodeTypes.FOR
            ? node.children
            : node.type === NodeTypes.TEXT
                || node.type === NodeTypes.COMMENT
                || node.type === NodeTypes.COMPOUND_EXPRESSION
                || node.type === NodeTypes.TEXT_CALL
                || node.type === NodeTypes.INTERPOLATION
                ? []
                : (_a = exhaustiveCheckReturnUndefined()) !== null && _a !== void 0 ? _a : [];
    return [...current, ...children.flatMap(getComponents)];
}
function getDirectiveNames(node) {
    if (node.type === NodeTypes.ELEMENT) {
        const directives = node.props.flatMap(x => x.type === NodeTypes.DIRECTIVE ? [x.name] : []);
        return [...directives, ...node.children.flatMap(getDirectiveNames)];
    }
    else if (node.type === NodeTypes.IF) {
        return node.branches.flatMap(getDirectiveNames);
    }
    else if (node.type === NodeTypes.IF_BRANCH || node.type === NodeTypes.FOR) {
        return node.children.flatMap(getDirectiveNames);
    }
    else if (node.type === NodeTypes.INTERPOLATION
        || node.type === NodeTypes.COMPOUND_EXPRESSION
        || node.type === NodeTypes.TEXT
        || node.type === NodeTypes.COMMENT
        || node.type === NodeTypes.TEXT_CALL) {
        return [];
    }
    else {
        return [];
    }
}
function getFreeVariablesForText(input) {
    const inputWithPrefix = input.trimStart()[0] === '{' ? `(${input})` : input;
    return getFileGlobals(parser.parse(inputWithPrefix));
}
function getFreeVariablesForPropsNode(node) {
    if (node.type === NodeTypes.DIRECTIVE) {
        const arg = node.arg === undefined ? [] : getFreeVariablesForNode(node.arg);
        const exp = node.exp === undefined ? [] : getFreeVariablesForNode(node.exp);
        return [...arg, ...exp];
    }
    return [];
}
function getFreeVariablesForNode(node) {
    var _a, _b, _c;
    if (node.type === NodeTypes.SIMPLE_EXPRESSION) {
        return node.isStatic ? [] : getFreeVariablesForText(node.content);
    }
    else if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
        return node.children.flatMap(x => typeof x !== 'object' ? [] : getFreeVariablesForNode(x));
    }
    else if (node.type === NodeTypes.INTERPOLATION) {
        return getFreeVariablesForNode(node.content);
    }
    else if (node.type === NodeTypes.ELEMENT) {
        const children = node.children.flatMap(getFreeVariablesForNode);
        const directiveProps = node.props.flatMap(x => x.type === NodeTypes.DIRECTIVE ? [x] : []);
        const attributeProps = node.props.flatMap(x => x.type === NodeTypes.ATTRIBUTE ? [x] : []);
        const refNode = attributeProps.find(node => node.name === 'ref' && node.value !== undefined);
        const refIdentifier = (_a = refNode === null || refNode === void 0 ? void 0 : refNode.value) === null || _a === void 0 ? void 0 : _a.content;
        const vSlotNode = directiveProps.find(node => node.name === 'slot');
        const vSlotArgIdentifiers = (vSlotNode === null || vSlotNode === void 0 ? void 0 : vSlotNode.arg) === undefined ? [] : getFreeVariablesForNode(vSlotNode.arg);
        // TODO: Variable shadowing
        const vSlotExpVariableShadowingIdentifiers = [];
        const vForNode = directiveProps.find(node => node.name === 'for');
        const vForIdentifiers = ((_b = vForNode === null || vForNode === void 0 ? void 0 : vForNode.exp) === null || _b === void 0 ? void 0 : _b.type) === NodeTypes.SIMPLE_EXPRESSION
            ? getFreeVariablesForText(vForNode.exp.content.replace(/^.*\s(?:in|of)\s/, ''))
            : [];
        // TODO: Variable shadowing
        const vForExpVariableShadowingIdentifiers = [];
        const props = directiveProps
            .filter(({ name }) => name !== 'slot' && name !== 'for')
            .flatMap(getFreeVariablesForPropsNode);
        const shadowingIdentifiers = new Set([
            ...vSlotExpVariableShadowingIdentifiers,
            ...vForExpVariableShadowingIdentifiers,
        ]);
        return [
            ...vSlotArgIdentifiers,
            refIdentifier,
            ...vForIdentifiers,
            ...[...children, ...props].filter(x => !shadowingIdentifiers.has(x)),
        ].filter(utils.notNullish);
    }
    else if (node.type === NodeTypes.FOR) {
        return [node.source, ...node.children].flatMap(getFreeVariablesForNode);
    }
    else if (node.type === NodeTypes.IF) {
        return ((_c = node.branches) !== null && _c !== void 0 ? _c : []).flatMap(getFreeVariablesForNode);
    }
    else if (node.type === NodeTypes.IF_BRANCH) {
        return [node.condition, ...node.children]
            .filter(utils.notNullish)
            .flatMap(getFreeVariablesForNode);
    }
    else if (node.type === NodeTypes.TEXT
        || node.type === NodeTypes.COMMENT
        || node.type === NodeTypes.TEXT_CALL) {
        return [];
    }
    else {
        return [];
    }
}
function findReferencesForSFC(templateNode) {
    var _a, _b, _c;
    const components = (_a = templateNode === null || templateNode === void 0 ? void 0 : templateNode.children.flatMap(getComponents)) !== null && _a !== void 0 ? _a : [];
    const directives = (_b = templateNode === null || templateNode === void 0 ? void 0 : templateNode.children.flatMap(getDirectiveNames)) !== null && _b !== void 0 ? _b : [];
    const identifiers = (_c = templateNode === null || templateNode === void 0 ? void 0 : templateNode.children.flatMap(getFreeVariablesForNode)) !== null && _c !== void 0 ? _c : [];
    return {
        components,
        directives,
        identifiers,
    };
}
function getBabelParserOptions(lang) {
    lang = lang || 'js';
    const pluginsDict = {
        js: [],
        ts: ['typescript'],
        jsx: ['jsx'],
        tsx: ['jsx', 'typescript'],
    };
    const plugins = pluginsDict[lang];
    if (plugins === undefined)
        throw new SyntaxError(`Unsupported script language: ${lang}`);
    return {
        sourceType: 'module',
        plugins,
    };
}
async function parseSFC(code, id, options) {
    var _a, _b, _c;
    const elementChildren = compilerCore.baseParse(code, compilerDom.parserOptions).children.flatMap(x => x.type === NodeTypes.ELEMENT && x.tagType === ElementTypes.ELEMENT
        ? [x]
        : []);
    const templateNode = elementChildren.find(x => x.tag === 'template');
    const [scriptSetupChildNodes, scriptChildNodes] = utils.partition(elementChildren.filter(x => x.tag === 'script'), x => x.props.some(p => p.type === NodeTypes.ATTRIBUTE && p.name === 'setup'));
    const getScriptTagMeta = (n, astTransforms = x => x) => {
        var _a, _b, _c, _d, _e, _f;
        if (n === undefined) {
            const content = '';
            const ast = parser.parse(content, {
                sourceType: 'module',
                plugins: [],
            }).program;
            return {
                start: 0,
                end: 0,
                contentStart: 0,
                contentEnd: 0,
                content,
                attrs: {},
                found: false,
                ast,
            };
        }
        const attrs = Object.fromEntries(n.props.flatMap(x => {
            var _a;
            return !(x.type === NodeTypes.ATTRIBUTE && typeof ((_a = x.value) === null || _a === void 0 ? void 0 : _a.content) === 'string')
                ? []
                : [[x.name, x.value.content]];
        }));
        const content = (_b = (_a = n.children[0]) === null || _a === void 0 ? void 0 : _a.loc.source) !== null && _b !== void 0 ? _b : '';
        const contentStart = (_d = (_c = n.children[0]) === null || _c === void 0 ? void 0 : _c.loc.start.offset) !== null && _d !== void 0 ? _d : 0;
        const contentEnd = (_f = (_e = n.children[0]) === null || _e === void 0 ? void 0 : _e.loc.end.offset) !== null && _f !== void 0 ? _f : 0;
        const ast = astTransforms(parser.parse(content, getBabelParserOptions(attrs.lang)).program);
        return {
            start: n.loc.start.offset,
            end: n.loc.end.offset,
            contentStart,
            contentEnd,
            content,
            attrs,
            found: true,
            ast,
        };
    };
    const scriptSetup = getScriptTagMeta(scriptSetupChildNodes[0], (_a = options === null || options === void 0 ? void 0 : options.astTransforms) === null || _a === void 0 ? void 0 : _a.scriptSetup);
    const script = getScriptTagMeta(scriptChildNodes[0], (_b = options === null || options === void 0 ? void 0 : options.astTransforms) === null || _b === void 0 ? void 0 : _b.script);
    if (script.found
        && scriptSetup.found
        && scriptSetup.attrs.lang !== script.attrs.lang) {
        throw new SyntaxError('<script setup> language must be the same as <script>');
    }
    const codeOfTemplate = templateNode == null
        ? undefined
        : templateNode.props.some(p => {
            var _a;
            return p.type === NodeTypes.ATTRIBUTE
                && p.name === 'lang'
                && ((_a = p.value) === null || _a === void 0 ? void 0 : _a.type) === NodeTypes.TEXT
                && p.value.content === 'pug';
        })
            ? compilerCore.baseParse((await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('pug')); })).compile(templateNode.children.map(x => x.loc.source).join(''), {
                filename: id,
            })(), compilerDom.parserOptions)
            : templateNode;
    const result = codeOfTemplate
        ? findReferencesForSFC(codeOfTemplate)
        : undefined;
    return {
        id,
        template: {
            components: new Set(result === null || result === void 0 ? void 0 : result.components.map(pascalize)),
            directives: new Set(result === null || result === void 0 ? void 0 : result.directives.filter(x => !BUILD_IN_DIRECTIVES.has(x)).map(shared.camelize)),
            identifiers: new Set(result === null || result === void 0 ? void 0 : result.identifiers),
        },
        scriptSetup,
        script,
        parserOptions: getBabelParserOptions((_c = script.attrs.lang) !== null && _c !== void 0 ? _c : scriptSetup.attrs.lang),
        extraDeclarations: [],
    };
}

// modified from https://github.com/vuejs/vue-next/blob/main/packages/compiler-sfc/src/compileScript.ts
// Special compiler macros
const DEFINE_PROPS = 'defineProps';
const DEFINE_EMITS = 'defineEmits';
const DEFINE_EXPOSE = 'defineExpose';
const WITH_DEFAULTS = 'withDefaults';
function applyMacros(nodes) {
    let hasDefinePropsCall = false;
    let hasDefineEmitCall = false;
    let propsRuntimeDecl;
    let propsRuntimeDefaults;
    let propsTypeDecl;
    let propsTypeDeclRaw;
    let emitsRuntimeDecl;
    let emitsTypeDecl;
    let emitsTypeDeclRaw;
    let exposeDecl;
    // props/emits declared via types
    const typeDeclaredProps = {};
    // record declared types for runtime props type generation
    const declaredTypes = {};
    function error(msg, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    node) {
        throw new Error(msg);
    }
    function processDefineProps(node) {
        if (!isCallOf(node, DEFINE_PROPS))
            return false;
        if (hasDefinePropsCall)
            error(`duplicate ${DEFINE_PROPS}() call`);
        hasDefinePropsCall = true;
        propsRuntimeDecl = node.arguments[0];
        // call has type parameters - infer runtime types from it
        if (node.typeParameters) {
            if (propsRuntimeDecl) {
                error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments `
                    + 'at the same time. Use one or the other.');
            }
            propsTypeDeclRaw = node.typeParameters.params[0];
            propsTypeDecl = resolveQualifiedType(propsTypeDeclRaw, node => node.type === 'TSTypeLiteral');
            if (!propsTypeDecl) {
                error(`type argument passed to ${DEFINE_PROPS}() must be a literal type, `
                    + 'or a reference to an interface or literal type.');
            }
        }
        return true;
    }
    function processWithDefaults(node) {
        if (!isCallOf(node, WITH_DEFAULTS))
            return false;
        if (processDefineProps(node.arguments[0])) {
            if (propsRuntimeDecl) {
                error(`${WITH_DEFAULTS} can only be used with type-based `
                    + `${DEFINE_PROPS} declaration.`);
            }
            propsRuntimeDefaults = node.arguments[1];
        }
        else {
            error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node.arguments[0] || node);
        }
        return true;
    }
    function processDefineEmits(node) {
        if (!isCallOf(node, DEFINE_EMITS))
            return false;
        if (hasDefineEmitCall)
            error(`duplicate ${DEFINE_EMITS}() call`);
        hasDefineEmitCall = true;
        emitsRuntimeDecl = node.arguments[0];
        if (node.typeParameters) {
            if (emitsRuntimeDecl) {
                error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments `
                    + 'at the same time. Use one or the other.');
            }
            emitsTypeDeclRaw = node.typeParameters.params[0];
            emitsTypeDecl = resolveQualifiedType(emitsTypeDeclRaw, node => node.type === 'TSFunctionType' || node.type === 'TSTypeLiteral');
            if (!emitsTypeDecl) {
                error(`type argument passed to ${DEFINE_EMITS}() must be a function type, `
                    + 'a literal type with call signatures, or a reference to the above types.');
            }
        }
        return true;
    }
    function resolveQualifiedType(node, qualifier) {
        if (qualifier(node))
            return node;
        if (node.type === 'TSTypeReference'
            && node.typeName.type === 'Identifier') {
            const refName = node.typeName.name;
            const isQualifiedType = (node) => {
                if (node.type === 'TSInterfaceDeclaration'
                    && node.id.name === refName)
                    return node.body;
                else if (node.type === 'TSTypeAliasDeclaration'
                    && node.id.name === refName
                    && qualifier(node.typeAnnotation))
                    return node.typeAnnotation;
                else if (node.type === 'ExportNamedDeclaration' && node.declaration)
                    return isQualifiedType(node.declaration);
            };
            for (const node of nodes) {
                const qualified = isQualifiedType(node);
                if (qualified)
                    return qualified;
            }
        }
    }
    function processDefineExpose(node) {
        if (!isCallOf(node, DEFINE_EXPOSE))
            return false;
        if (exposeDecl)
            error(`duplicate ${DEFINE_EXPOSE}() call`);
        if (node.arguments.length !== 1)
            error(`${DEFINE_EXPOSE}() requires one argument`);
        exposeDecl = node.arguments[0];
        return true;
    }
    function genRuntimeProps(props) {
        const keys = Object.keys(props);
        if (!keys.length)
            return undefined;
        // check defaults. If the default object is an object literal with only
        // static properties, we can directly generate more optimzied default
        // decalrations. Otherwise we will have to fallback to runtime merging.
        const hasStaticDefaults = propsRuntimeDefaults
            && propsRuntimeDefaults.type === 'ObjectExpression'
            && propsRuntimeDefaults.properties.every(node => node.type === 'ObjectProperty' && !node.computed);
        return t.objectExpression(Object.entries(props).map(([key, value]) => {
            const prop = hasStaticDefaults
                ? propsRuntimeDefaults.properties.find((node) => node.key.name === key)
                : undefined;
            if (prop)
                value.required = false;
            const entries = Object.entries(value).map(([key, value]) => key === 'type'
                ? t.objectProperty(t.identifier(key), typeof value === 'string' ? t.identifier(value) : t.arrayExpression(value.map((i) => t.identifier(i))))
                : t.objectProperty(t.identifier(key), parser.parseExpression(JSON.stringify(value))));
            if (prop)
                entries.push(t.objectProperty(t.identifier('default'), prop.value));
            return t.objectProperty(t.identifier(key), t.objectExpression(entries));
        }));
    }
    function getProps() {
        if (propsRuntimeDecl)
            return propsRuntimeDecl;
        if (propsTypeDecl) {
            extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
            return genRuntimeProps(typeDeclaredProps);
        }
    }
    function throwIfAwait(node) {
        if (node.type === 'AwaitExpression')
            error('top-level await is not supported in Vue 2');
    }
    nodes = nodes
        .map((raw) => {
        let node = raw;
        if (raw.type === 'ExpressionStatement')
            node = raw.expression;
        if (node.type === 'VariableDeclaration' && !node.declare) {
            const total = node.declarations.length;
            for (let i = 0; i < total; i++) {
                const decl = node.declarations[i];
                if (decl.init) {
                    if (processDefineEmits(decl.init))
                        decl.init = t.memberExpression(t.identifier('__ctx'), t.identifier('emit'));
                    else if (processDefineProps(decl.init) || processWithDefaults(decl.init))
                        decl.init = t.identifier('__props');
                    else
                        throwIfAwait(decl.init);
                }
            }
        }
        if (processWithDefaults(node) || processDefineEmits(node) || processDefineProps(node) || processDefineExpose(node))
            return null;
        throwIfAwait(node);
        return raw;
    })
        .filter(Boolean);
    return {
        nodes,
        props: getProps(),
        expose: exposeDecl,
    };
}
function isCallOf(node, test) {
    return !!(node
        && node.type === 'CallExpression'
        && node.callee.type === 'Identifier'
        && (typeof test === 'string'
            ? node.callee.name === test
            : test(node.callee.name)));
}
function extractRuntimeProps(node, props, declaredTypes) {
    const members = node.type === 'TSTypeLiteral' ? node.members : node.body;
    for (const m of members) {
        if ((m.type === 'TSPropertySignature' || m.type === 'TSMethodSignature')
            && m.key.type === 'Identifier') {
            let type;
            if (m.type === 'TSMethodSignature') {
                type = ['Function'];
            }
            else if (m.typeAnnotation) {
                type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes);
            }
            props[m.key.name] = {
                key: m.key.name,
                required: !m.optional,
                type: (type === null || type === void 0 ? void 0 : type.length) === 1 ? type[0] : type || 'null',
            };
        }
    }
}
function inferRuntimeType(node, declaredTypes) {
    switch (node.type) {
        case 'TSStringKeyword':
            return ['String'];
        case 'TSNumberKeyword':
            return ['Number'];
        case 'TSBooleanKeyword':
            return ['Boolean'];
        case 'TSObjectKeyword':
            return ['Object'];
        case 'TSTypeLiteral':
            // TODO (nice to have) generate runtime property validation
            return ['Object'];
        case 'TSFunctionType':
            return ['Function'];
        case 'TSArrayType':
        case 'TSTupleType':
            // TODO (nice to have) generate runtime element type/length checks
            return ['Array'];
        case 'TSLiteralType':
            switch (node.literal.type) {
                case 'StringLiteral':
                    return ['String'];
                case 'BooleanLiteral':
                    return ['Boolean'];
                case 'NumericLiteral':
                case 'BigIntLiteral':
                    return ['Number'];
                default:
                    return ['null'];
            }
        case 'TSTypeReference':
            if (node.typeName.type === 'Identifier') {
                if (declaredTypes[node.typeName.name])
                    return declaredTypes[node.typeName.name];
                switch (node.typeName.name) {
                    case 'Array':
                    case 'Function':
                    case 'Object':
                    case 'Set':
                    case 'Map':
                    case 'WeakSet':
                    case 'WeakMap':
                        return [node.typeName.name];
                    case 'Record':
                    case 'Partial':
                    case 'Readonly':
                    case 'Pick':
                    case 'Omit':
                    case 'Exclude':
                    case 'Extract':
                    case 'Required':
                    case 'InstanceType':
                        return ['Object'];
                }
            }
            return ['null'];
        case 'TSParenthesizedType':
            return inferRuntimeType(node.typeAnnotation, declaredTypes);
        case 'TSUnionType':
            return [
                ...new Set([].concat(...node.types.map(t => inferRuntimeType(t, declaredTypes)))),
            ];
        case 'TSIntersectionType':
            return ['Object'];
        default:
            return ['null']; // no runtime check
    }
}

function isAsyncImport(node) {
    if (t.isVariableDeclaration(node)) {
        const declaration = node.declarations[0];
        return (declaration !== undefined
            && t.isCallExpression(declaration.init)
            && t.isIdentifier(declaration.init.callee)
            && declaration.init.callee.name === 'defineAsyncComponent');
    }
    return false;
}
function transformScriptSetup(sfc, options) {
    var _a, _b;
    const { scriptSetup, script, template } = sfc;
    const { nodes: body, props, expose } = applyMacros(scriptSetup.ast.body);
    const [hoisted, setupBody] = utils.partition(body, n => isAsyncImport(n)
        || t.isImportDeclaration(n)
        || t.isExportNamedDeclaration(n)
        || n.type.startsWith('TS'));
    // get all identifiers in `<script setup>` and `<script>`
    const declarationArray = utils.uniq([
        ...getIdentifierDeclarations(hoisted),
        ...getIdentifierDeclarations(setupBody),
        ...getIdentifierDeclarations(script.ast.body),
    ]).filter(utils.notNullish);
    // filter out identifiers that are used in `<template>`
    const returns = declarationArray
        .filter(i => template.identifiers.has(i))
        .map((i) => {
        const id = t.identifier(i);
        return t.objectProperty(id, id, false, true);
    });
    const components = Array.from(template.components)
        .map(component => {
        var _a;
        return (_a = declarationArray.find(declare => declare === component)) !== null && _a !== void 0 ? _a : declarationArray.find(declare => pascalize(declare) === component);
    })
        .filter(utils.notNullish);
    const directiveDeclaration = Array.from(template.directives)
        .map((directive) => {
        const identifier = declarationArray.find(declaration => declaration === `v${shared.capitalize(directive)}`);
        if (identifier === undefined)
            return undefined;
        return { identifier, directive };
    })
        .filter(utils.notNullish);
    // append `<script setup>` imports to `<script>`
    const __sfc = t.identifier('__sfc_main');
    let hasBody = false;
    const bodyNodes = script.ast.body.map((node) => {
        // replace `export default` with a temproray variable
        // `const __sfc_main = { ... }`
        if (node.type === 'ExportDefaultDeclaration') {
            hasBody = true;
            return t.variableDeclaration('const', [
                t.variableDeclarator(__sfc, node.declaration),
            ]);
        }
        return node;
    });
    let ast = t.program([
        ...sfc.extraDeclarations,
        ...hoisted,
        ...bodyNodes,
    ]);
    // inject `const __sfc_main = {}` if `<script>` has default export
    if (!hasBody) {
        ast.body.push(t.variableDeclaration('const', [
            t.variableDeclarator(__sfc, t.objectExpression([])),
        ]));
    }
    // inject props function
    // `__sfc_main.props = { ... }`
    if (props) {
        hasBody = true;
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('props')), props)));
    }
    // inject setup function
    // `__sfc_main.setup = () => {}`
    if (body.length) {
        hasBody = true;
        const returnExpr = expose
            ? t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [t.objectExpression(returns), expose])
            : t.objectExpression(returns);
        const returnStatement = t.returnStatement(returnExpr);
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('setup')), t.arrowFunctionExpression([t.identifier('__props'), t.identifier('__ctx')], t.blockStatement([...setupBody, returnStatement])))));
    }
    // inject components
    // `__sfc_main.components = Object.assign({ ... }, __sfc_main.components)`
    if (components.length) {
        hasBody = true;
        const componentsObject = t.objectExpression(components.map((i) => {
            const id = t.identifier(i);
            return t.objectProperty(id, id, false, true);
        }));
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('components')), t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [
            componentsObject,
            t.memberExpression(__sfc, t.identifier('components')),
        ]))));
    }
    // inject directives
    // `__sfc_main.directives = Object.assign({ ... }, __sfc_main.directives)`
    if (directiveDeclaration.length) {
        hasBody = true;
        const directivesObject = t.objectExpression(directiveDeclaration.map(({ directive, identifier }) => t.objectProperty(t.identifier(directive), t.identifier(identifier), false, false)));
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('directives')), t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [
            directivesObject,
            t.memberExpression(__sfc, t.identifier('directives')),
        ]))));
    }
    if (!hasBody && !(options === null || options === void 0 ? void 0 : options.astTransforms)) {
        return {
            ast: null,
            code: '',
        };
    }
    // re-export
    // `export default __sfc_main`
    ast.body.push(t.exportDefaultDeclaration(__sfc));
    ast = ((_b = (_a = options === null || options === void 0 ? void 0 : options.astTransforms) === null || _a === void 0 ? void 0 : _a.post) === null || _b === void 0 ? void 0 : _b.call(_a, ast, sfc)) || ast;
    return {
        ast,
        code: generate(ast).code,
    };
}

function transformSfcRefSugar(sfc, options) {
    const importedHelpers = new Set();
    for (const script of [sfc.script, sfc.scriptSetup]) {
        if (reactivityTransform.shouldTransform(script.content)) {
            const s = new MagicString__default["default"](script.content);
            const { importedHelpers: imports } = reactivityTransform.transformAST(script.ast, s);
            Array.from(imports).forEach(helper => importedHelpers.add(helper));
            script.content = s.toString();
            script.ast = parser.parse(script.content, sfc.parserOptions).program;
        }
    }
    if (importedHelpers.size) {
        sfc.extraDeclarations = [
            t.importDeclaration(Array.from(importedHelpers).map(i => t.importSpecifier(t.identifier(`_${i}`), t.identifier(i))), t.stringLiteral(options.importHelpersFrom)),
        ];
    }
}

function resolveOptions(options = {}) {
    return Object.assign({}, {
        sourceMap: true,
        reactivityTransform: false,
        importHelpersFrom: '@vue/composition-api',
        astTransforms: {},
    }, options);
}

const scriptSetupRE = /<script\s(.*\s)?setup(\s.*)?>/;
function shouldTransform(code, id, options) {
    // avoid transforming twice
    if (code.includes('export default __sfc_main'))
        return false;
    return ((options === null || options === void 0 ? void 0 : options.reactivityTransform) && reactivityTransform.shouldTransform(code)) || scriptSetupRE.test(code);
}
async function transform(input, id, options) {
    if (!shouldTransform(input, id, options))
        return null;
    const resolved = resolveOptions(options);
    if (id.endsWith('.vue') || id.includes('.vue?vue'))
        return await transformVue(input, id, resolved);
    else
        return transformNonVue(input, id, resolved);
}
function transformNonVue(input, id, options) {
    if (options.reactivityTransform && reactivityTransform.shouldTransform(input)) {
        return reactivityTransform.transform(input, {
            filename: id,
            sourceMap: options.sourceMap,
            importHelpersFrom: options.importHelpersFrom,
        });
    }
    return null;
}
async function transformVue(input, id, options) {
    const s = new MagicString__default["default"](input);
    const sfc = await parseSFC(input, id);
    if (options.reactivityTransform)
        transformSfcRefSugar(sfc, options);
    const { code } = transformScriptSetup(sfc, options);
    const attributes = Object.assign(Object.assign({}, sfc.script.attrs), sfc.scriptSetup.attrs);
    delete attributes.setup;
    const attr = Object.entries(attributes)
        .map(([key, value]) => value ? `${key}="${value}"` : key)
        .join(' ');
    if (code) {
        const block = `<script ${attr}>\n${code}\n</script>`;
        s.remove(sfc.script.start, sfc.script.end);
        if (sfc.scriptSetup.start !== sfc.scriptSetup.end) {
            s.overwrite(sfc.scriptSetup.start, sfc.scriptSetup.end, block);
        }
        else {
            s.prependLeft(0, `${block}\n`);
        }
    }
    return {
        code: s.toString(),
        map: options.sourceMap
            ? s.generateMap({
                source: id,
                includeContent: true,
            })
            : null,
    };
}

const unplugin = unplugin$1.createUnplugin((options = {}) => {
    const filter = pluginutils.createFilter(options.include || (options.reactivityTransform ? [/\.vue$/, /\.vue\?vue/, /\.[jt]sx?$/] : [/\.vue$/, /\.vue\?vue/]), options.exclude || [/node_modules/, /\.git/, /\.nuxt/]);
    return {
        name: 'unplugin-vue2-script-setup',
        enforce: 'pre',
        transformInclude(id) {
            return filter(id);
        },
        async transform(code, id) {
            try {
                return await transform(code, id, options);
            }
            catch (e) {
                this.error(e);
            }
        },
    };
});

var webpack = unplugin.webpack;

exports["default"] = webpack;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2VicGFjay5qcyIsInNvdXJjZXMiOltdLCJzb3VyY2VzQ29udGVudCI6W10sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
